:callstack_idx
DAT callstack

:heap_idx
DAT 0x4000

:callstack
DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

:prn_stack
.DAT 0, 0, 0, 0, 0, 0 ; -xxxxx is the largest number that can be displayed

.DEF VRAMADDRESS, 0x8000
.DEF VRAMWORDS, 386
.DEF SCREENWIDTH, 32
.DEF SCREENHEIGHT, 12

:screen_cursor
DAT 0

:boot_screen
    HWN I ; get connected hardware count

    :discovery

    SUB I, 1

    IFU I, 0
    SET PC, finished_discovery ; terminate if I < 0

    HWQ I ; this overwrites A,B,C,X,Y

    IFN A, 0xf615
    SET PC, discovery ; not screen
    IFN B, 0x7349
    SET PC, discovery ; not screen

    SET A, 0           ; MEM_MAP_SCREEN
    SET B, VRAMADDRESS ; Will initialise the LEM and set the vram address

    HWI I              ; Command the LEM to turn on
    :finished_discovery
    SET PC, POP
;end boot screen

:gt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFA A, B
SET C, 1
SET PUSH, C
SET PC, Y

:ge
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFU A, B
SET C, 0
SET PUSH, C
SET PC, Y

:lt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFU A, B
SET C, 1
SET PUSH, C
SET PC, Y

:le
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFA A, B
SET C, 0
SET PUSH, C
SET PC, Y

:prn
    SET Y, POP ; return address
    SET I, POP ; number to print as a string
    SET J, [screen_cursor]
    SET X, 0 ; prn stack index
    SET A, 0 ; is negative
    
    IFE I, 0
    SET PC, not_negative
    IFA I, 0 ; assumes number is signed
    SET PC, not_negative
    
    ; take positive value. won't handle INT_MIN correctly
    XOR I, 0xFFFF
    ADD I, 1
        
    SET [0 + prn_stack], -3 ; everything at the end will have 48 added, so this gives us '-'
    SET [1 + prn_stack], -3
    SET [2 + prn_stack], -3
    SET [3 + prn_stack], -3
    SET [4 + prn_stack], -3
    SET [5 + prn_stack], -3
    
    SET A, 1 ; is negative
        
    :not_negative
        :prn_loop
        IFL I, 10
        SET PC, lt_ten
        
        SET Y, I
        MOD Y, 10 ; display in base 10
        DIV I, 10 
        
        SET [X + prn_stack], Y
        ADD X, 1
        
        SET PC, prn_loop


    :lt_ten
    SET [X + prn_stack], I
    ADD X, 1
    
    IFE A, 1 ; if negative
    ADD X, 1 ; bump pointer
    
        :prn_display
        SUB X, 1
        
        IFU X, 0
        SET PC, prn_done
        
        SET Y, [prn_stack + X]
        ADD Y, 48
        SET [J + VRAMADDRESS], Y
        ADD [J + VRAMADDRESS], 0xF000
        
        ADD J, 1
        MOD J, VRAMWORDS
        
        SET PC, prn_display
        
    :prn_done
        
    SET [screen_cursor], J

    SET PC, Y
; end prn

; print string. stack is [address, returnaddr]. string is null terminated
:prs
    SET Y, POP ; return address
    SET I, POP ; address of string start
    XOR I, 0xFFFF ; get memory location of I on stack
    SET J, [screen_cursor]
    :not_null

        IFE [I], 0 ; null
        SET PC, found_null ; terminate loop

        SET [J + VRAMADDRESS], [I]
        SUB I, 1
        ADD [J + VRAMADDRESS], 0b1111000000000000 ; set character to white
        ADD J, 1
        MOD J, VRAMWORDS ; wraparound

        SET PC, not_null

    :found_null

    SET [screen_cursor], J ; update screen cursor

    SET PC, Y ; done
;end prs

:prc
    SET Y, POP 
    SET I, POP ; value
    
    SET J, [screen_cursor]

    SET [J + VRAMADDRESS], I
    ADD [J + VRAMADDRESS], 0b1111000000000000 ; set character to white
    ADD J, 1
    MOD J, VRAMWORDS ; wraparound
    
    SET [screen_cursor], J

    SET PC, Y
; end prc

:prend
SET Y, POP
SET PC, Y

:getch
SET Y, POP
SET PUSH, 0
SET PC, Y
