:callstack_idx
DAT callstack

:prs_dir
DAT 1

:heap_idx
DAT 0x4000

; well this is silly. Its for vram, indexing into it gives the next character of vram to use
:next_modulo_table
DAT 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 0, 1, 2, 3

:white_ascii
DAT 0xf000, 0xf001, 0xf002, 0xf003, 0xf004, 0xf005, 0xf006, 0xf007, 0xf008, 0xf009, 0xf00a, 0xf00b, 0xf00c, 0xf00d, 0xf00e, 0xf00f, 0xf010, 0xf011, 0xf012, 0xf013, 0xf014, 0xf015, 0xf016, 0xf017, 0xf018, 0xf019, 0xf01a, 0xf01b, 0xf01c, 0xf01d, 0xf01e, 0xf01f, 0xf020, 0xf021, 0xf022, 0xf023, 0xf024, 0xf025, 0xf026, 0xf027, 0xf028, 0xf029, 0xf02a, 0xf02b, 0xf02c, 0xf02d, 0xf02e, 0xf02f, 0xf030, 0xf031, 0xf032, 0xf033, 0xf034, 0xf035, 0xf036, 0xf037, 0xf038, 0xf039, 0xf03a, 0xf03b, 0xf03c, 0xf03d, 0xf03e, 0xf03f, 0xf040, 0xf041, 0xf042, 0xf043, 0xf044, 0xf045, 0xf046, 0xf047, 0xf048, 0xf049, 0xf04a, 0xf04b, 0xf04c, 0xf04d, 0xf04e, 0xf04f, 0xf050, 0xf051, 0xf052, 0xf053, 0xf054, 0xf055, 0xf056, 0xf057, 0xf058, 0xf059, 0xf05a, 0xf05b, 0xf05c, 0xf05d, 0xf05e, 0xf05f, 0xf060, 0xf061, 0xf062, 0xf063, 0xf064, 0xf065, 0xf066, 0xf067, 0xf068, 0xf069, 0xf06a, 0xf06b, 0xf06c, 0xf06d, 0xf06e, 0xf06f, 0xf070, 0xf071, 0xf072, 0xf073, 0xf074, 0xf075, 0xf076, 0xf077, 0xf078, 0xf079, 0xf07a, 0xf07b, 0xf07c, 0xf07d, 0xf07e, 0xf07f

:callstack
DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

:prn_stack
DAT 0, 0, 0, 0, 0, 0 ; -xxxxx is the largest number that can be displayed

;.DEF VRAMADDRESS, 0x8000
;.DEF VRAMWORDS, 384
;.DEF SCREENWIDTH, 32
;.DEF SCREENHEIGHT, 12

:screen_cursor
DAT 0

:boot_screen
    HWN I ; get connected hardware count

    :discovery

    SUB I, 1

    IFU I, 0
    SET PC, finished_discovery ; terminate if I < 0

    HWQ I ; this overwrites A,B,C,X,Y

    IFN A, 0xf615
    SET PC, discovery ; not screen
    IFN B, 0x7349
    SET PC, discovery ; not screen

    SET A, 0           ; MEM_MAP_SCREEN
    SET B, 0x8000 ; Will initialise the LEM and set the vram address

    HWI I              ; Command the LEM to turn on
    :finished_discovery
    SET PC, POP
;end boot screen

:gt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFA A, B
SET C, 1
SET PUSH, C
SET PC, Y

:ge
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFU A, B
SET C, 0
SET PUSH, C
SET PC, Y

:lt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFU A, B
SET C, 1
SET PUSH, C
SET PC, Y

:le
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFA A, B
SET C, 0
SET PUSH, C
SET PC, Y

:prn
    SET Y, POP ; return address
    SET I, POP ; number to print as a string
    SET J, I  ; backup
    SET C, SP ; backup

    SET PUSH, 0

    :not_negative
        :prn_loop
        IFL I, 10
        SET PC, lt_ten
        
        SET PUSH, I
        MOD PEEK, 10 ; display in base 10
        ADD PEEK, 48

        DIV I, 10 
        
        SET PC, prn_loop

    :lt_ten
    ADD I, 48
    SET PUSH, I

    IFU J, 0
    SET PUSH, 45

    SET [prs_dir], -1

    SET I, SP
    SET SP, C ; use backup stack pointer

    ; avoids pushing values to the stack
    SET A, prn_done
    SET PC, prs_with_A_I
    :prn_done

    SET [prs_dir], 1
        
    SET PC, Y
; end prn

; print string. stack is [address, returnaddr]. string is null terminated
:prs
    SET A, POP ; return address
    SET I, POP ; address of string start
    XOR I, 0xFFFF ; get memory location of I on stack. This is the only line of code that cares about memory location in std.d16
:prs_with_A_I
    SET J, [screen_cursor]
    :not_null

        IFL [I], 11 ; 0 is null, 10 is newline
        SET PC, prs_special_character_trampoline
        
        :prs_notspecial
        
        SET Z, [I]
        SET [J + 0x8000], [Z + white_ascii] ; set character to white
        
        SET J, [next_modulo_table + J]
        
        :prs_skip

        SUB I, [prs_dir]
        SET PC, not_null

    :prs_found_null

    SET [screen_cursor], J ; update screen cursor

    SET PC, A ; done
;end prs

:prs_special_character_trampoline

    ;(if [I] != '\n' && [I] != null) goto prs_notspecial
    IFN [I], 10
    IFN [I], 0
    SET PC, prs_notspecial

    ; null
    IFE [I], 0
    SET PC, prs_found_null

    ; newline
    SET [screen_cursor], J
    JSR prend
    SET PC, prs_skip

;end prs_special_character_trampoline

:prc
    SET Y, POP 
    SET I, POP ; value
    
    IFE I, 10 ; newline, use prend
    SET PC, prend_with_y
    
    SET J, [screen_cursor]

    SET [J + 0x8000], [I + white_ascii] ; set character to white

    SET [screen_cursor], [next_modulo_table + J]
    
    SET PC, Y
; end prc

:next_screen_cursor
DAT 0
:next_next_screen_cursor
DAT 0

; this function only uses Y, and J
:prend
SET Y, POP
:prend_with_y
MOD [screen_cursor], 384
SET [next_screen_cursor], [screen_cursor]

; round upwards to next multiple of 32
ADD [next_screen_cursor], 32
DVI [next_screen_cursor], 32
MLI [next_screen_cursor], 32

SET [next_next_screen_cursor], [next_screen_cursor]
ADD [next_next_screen_cursor], 32
MOD [next_screen_cursor], 384
MOD [next_next_screen_cursor], 384

SET J, [screen_cursor]

    :blank_current_line
    ; already blanked line
    IFC [J + 0x8000], 0b1111111100000000 ; if front and back colour are 0, aka all black
    SET PC, setup_blank_next_line

    ; black space
    SET [J + 0x8000], 0b0000000000001010
    SET J, [next_modulo_table + J]

    IFN J, [next_screen_cursor]
    SET PC, blank_current_line
    
    
    
    :setup_blank_next_line
    SET J, [next_screen_cursor]



    :blank_next_line
    IFC [J + 0x8000], 0b1111111100000000
    SET PC, fin_blank_next_line

    ; black space
    SET [J + 0x8000], 0b0000000000001010
    SET J, [next_modulo_table + J]
    
    IFN J, [next_next_screen_cursor]
    SET PC, blank_next_line

    :fin_blank_next_line



SET J, [next_screen_cursor]
SET [screen_cursor], [next_screen_cursor]
SET PC, Y

:getch
SET Y, POP
SET PUSH, 0
SET PC, Y
