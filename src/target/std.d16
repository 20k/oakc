:callstack_idx
DAT callstack

; well this is silly. Its for vram, indexing into it gives the next character of vram to use
:next_modulo_table
DAT 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 366, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 0, 1, 2, 3

:heap_idx
DAT 0x4000

:callstack
DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

:prn_stack
DAT 0, 0, 0, 0, 0, 0 ; -xxxxx is the largest number that can be displayed

;.DEF VRAMADDRESS, 0x8000
;.DEF VRAMWORDS, 386
;.DEF SCREENWIDTH, 32
;.DEF SCREENHEIGHT, 12

:screen_cursor
DAT 0

:boot_screen
    HWN I ; get connected hardware count

    :discovery

    SUB I, 1

    IFU I, 0
    SET PC, finished_discovery ; terminate if I < 0

    HWQ I ; this overwrites A,B,C,X,Y

    IFN A, 0xf615
    SET PC, discovery ; not screen
    IFN B, 0x7349
    SET PC, discovery ; not screen

    SET A, 0           ; MEM_MAP_SCREEN
    SET B, 0x8000 ; Will initialise the LEM and set the vram address

    HWI I              ; Command the LEM to turn on
    :finished_discovery
    SET PC, POP
;end boot screen

:gt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFA A, B
SET C, 1
SET PUSH, C
SET PC, Y

:ge
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFU A, B
SET C, 0
SET PUSH, C
SET PC, Y

:lt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFU A, B
SET C, 1
SET PUSH, C
SET PC, Y

:le
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFA A, B
SET C, 0
SET PUSH, C
SET PC, Y

:prn
    SET Y, POP ; return address
    SET I, POP ; number to print as a string
    SET J, [screen_cursor]
    SET X, 0 ; prn stack index
    SET A, 0 ; is negative
    
    IFE I, 0
    SET PC, not_negative
    IFA I, 0 ; assumes number is signed
    SET PC, not_negative
    
    ; take positive value. won't handle INT_MIN correctly
    XOR I, 0xFFFF
    ADD I, 1
        
    SET [0 + prn_stack], -3 ; everything at the end will have 48 added, so this gives us '-'
    SET [1 + prn_stack], -3
    SET [2 + prn_stack], -3
    SET [3 + prn_stack], -3
    SET [4 + prn_stack], -3
    SET [5 + prn_stack], -3
    
    SET A, 1 ; is negative
        
    :not_negative
        :prn_loop
        IFL I, 10
        SET PC, lt_ten
        
        SET B, I
        MOD B, 10 ; display in base 10
        DIV I, 10 
        
        SET [X + prn_stack], B
        ADD X, 1
        
        SET PC, prn_loop


    :lt_ten
    SET [X + prn_stack], I
    ADD X, 1
    
    IFE A, 1 ; if negative
    ADD X, 1 ; bump pointer
    
        :prn_display
        SUB X, 1
        
        IFU X, 0
        SET PC, prn_done
        
        SET B, [prn_stack + X]
        ADD B, 48
        SET [J + 0x8000], B
        ADD [J + 0x8000], 0xF000
        
        ADD J, 1
        MOD J, 386
        
        SET PC, prn_display
        
    :prn_done
        
    SET [screen_cursor], J

    SET PC, Y
; end prn

; print string. stack is [address, returnaddr]. string is null terminated
:prs
    SET A, POP ; return address
    SET I, POP ; address of string start
    XOR I, 0xFFFF ; get memory location of I on stack
    SET J, [screen_cursor]
    :not_null

        IFL [I], 11 ; 0 is null, 10 is newline
        SET PC, prs_special_character_trampoline
        
        :prs_notspecial
        
        SET [J + 0x8000], [I]
        
        ADD [J + 0x8000], 0b1111000000000000 ; set character to white
        SET J, [next_modulo_table + J]
        
        :prs_skip

        SUB I, 1
        SET PC, not_null

    :prs_found_null

    SET [screen_cursor], J ; update screen cursor

    SET PC, A ; done
;end prs

:prs_special_character_trampoline

    ;(if [I] != '\n' && [I] != null) goto prs_notspecial
    IFN [I], 10
    IFN [I], 0
    SET PC, prs_notspecial

    ; null
    IFE [I], 0
    SET PC, prs_found_null

    ; newline
    SET [screen_cursor], J
    JSR prend
    SET PC, prs_skip

;end prs_special_character_trampoline

:prc
    SET Y, POP 
    SET I, POP ; value
    
    IFE I, 10 ; newline, use prend
    SET PC, prend_with_y
    
    SET J, [screen_cursor]

    SET [J + 0x8000], I
    ADD [J + 0x8000], 0b1111000000000000 ; set character to white

    SET [screen_cursor], [next_modulo_table + J]
    
    SET PC, Y
; end prc

:next_screen_cursor
DAT 0
:next_next_screen_cursor
DAT 0

; this function only uses Y, and J
:prend
SET Y, POP
:prend_with_y
SET [next_screen_cursor], [screen_cursor]
MOD [next_screen_cursor], 386

; round upwards to next multiple of 32
ADD [next_screen_cursor], 32
DVI [next_screen_cursor], 32
MLI [next_screen_cursor], 32

SET [next_next_screen_cursor], [next_screen_cursor]
ADD [next_next_screen_cursor], 32
MOD [next_screen_cursor], 386
MOD [next_next_screen_cursor], 386

SET J, [screen_cursor]

    :blank_current_line
    ; already blanked line
    IFC [J + 0x8000], 0b1111111100000000 ; if front and back colour are 0, aka all black
    SET PC, setup_blank_next_line

    ; black space
    SET [J + 0x8000], 0b0000000000001010
    SET J, [next_modulo_table + J]

    IFN J, [next_screen_cursor]
    SET PC, blank_current_line
    
    
    
    :setup_blank_next_line
    SET J, [next_screen_cursor]



    :blank_next_line
    IFC [J + 0x8000], 0b1111111100000000
    SET PC, fin_blank_next_line

    ; black space
    SET [J + 0x8000], 0b0000000000001010
    SET J, [next_modulo_table + J]
    
    IFN J, [next_next_screen_cursor]
    SET PC, blank_next_line

    :fin_blank_next_line



SET J, [next_screen_cursor]
SET [screen_cursor], [next_screen_cursor]
SET PC, Y

:getch
SET Y, POP
SET PUSH, 0
SET PC, Y
