:callstack_idx
DAT callstack

:heap_idx
DAT 0x4000

:callstack
DAT 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

:prn_stack
DAT 0, 0, 0, 0, 0, 0 ; -xxxxx is the largest number that can be displayed

;.DEF VRAMADDRESS, 0x8000
;.DEF VRAMWORDS, 386
;.DEF SCREENWIDTH, 32
;.DEF SCREENHEIGHT, 12

:screen_cursor
DAT 0

:boot_screen
    HWN I ; get connected hardware count

    :discovery

    SUB I, 1

    IFU I, 0
    SET PC, finished_discovery ; terminate if I < 0

    HWQ I ; this overwrites A,B,C,X,Y

    IFN A, 0xf615
    SET PC, discovery ; not screen
    IFN B, 0x7349
    SET PC, discovery ; not screen

    SET A, 0           ; MEM_MAP_SCREEN
    SET B, 0x8000 ; Will initialise the LEM and set the vram address

    HWI I              ; Command the LEM to turn on
    :finished_discovery
    SET PC, POP
;end boot screen

:gt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFA A, B
SET C, 1
SET PUSH, C
SET PC, Y

:ge
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFU A, B
SET C, 0
SET PUSH, C
SET PC, Y

:lt
SET Y, POP
SET A, POP
SET B, POP
SET C, 0
IFU A, B
SET C, 1
SET PUSH, C
SET PC, Y

:le
SET Y, POP
SET A, POP
SET B, POP
SET C, 1
IFA A, B
SET C, 0
SET PUSH, C
SET PC, Y

:prn
    SET Y, POP ; return address
    SET I, POP ; number to print as a string
    SET J, [screen_cursor]
    SET X, 0 ; prn stack index
    SET A, 0 ; is negative
    
    IFE I, 0
    SET PC, not_negative
    IFA I, 0 ; assumes number is signed
    SET PC, not_negative
    
    ; take positive value. won't handle INT_MIN correctly
    XOR I, 0xFFFF
    ADD I, 1
        
    SET [0 + prn_stack], -3 ; everything at the end will have 48 added, so this gives us '-'
    SET [1 + prn_stack], -3
    SET [2 + prn_stack], -3
    SET [3 + prn_stack], -3
    SET [4 + prn_stack], -3
    SET [5 + prn_stack], -3
    
    SET A, 1 ; is negative
        
    :not_negative
        :prn_loop
        IFL I, 10
        SET PC, lt_ten
        
        SET B, I
        MOD B, 10 ; display in base 10
        DIV I, 10 
        
        SET [X + prn_stack], B
        ADD X, 1
        
        SET PC, prn_loop


    :lt_ten
    SET [X + prn_stack], I
    ADD X, 1
    
    IFE A, 1 ; if negative
    ADD X, 1 ; bump pointer
    
        :prn_display
        SUB X, 1
        
        IFU X, 0
        SET PC, prn_done
        
        SET B, [prn_stack + X]
        ADD B, 48
        SET [J + 0x8000], B
        ADD [J + 0x8000], 0xF000
        
        ADD J, 1
        MOD J, 386
        
        SET PC, prn_display
        
    :prn_done
        
    SET [screen_cursor], J

    SET PC, Y
; end prn

; print string. stack is [address, returnaddr]. string is null terminated
:prs
    SET A, POP ; return address
    SET I, POP ; address of string start
    XOR I, 0xFFFF ; get memory location of I on stack
    SET J, [screen_cursor]
    :not_null

        IFE [I], 0 ; null
        SET PC, found_null ; terminate loop        
        
        SET [screen_cursor], J
        
        IFE [I], 10 ; 10 is '\n'
        JSR prend
        
        IFE [I], 10 ; skip
        SET PC, prs_skip
        
        SET [J + 0x8000], [I]
        
        ADD [J + 0x8000], 0b1111000000000000 ; set character to white
        ADD J, 1
        MOD J, 386 ; wraparound
        
        :prs_skip

        SUB I, 1
        SET PC, not_null

    :found_null

    SET [screen_cursor], J ; update screen cursor

    SET PC, A ; done
;end prs

:prc
    SET Y, POP 
    SET I, POP ; value
    
    IFE I, 10 ; newline, use prend
    SET PC, prend_with_y
    
    SET J, [screen_cursor]

    SET [J + 0x8000], I
    ADD [J + 0x8000], 0b1111000000000000 ; set character to white
    ADD J, 1
    MOD J, 386 ; wraparound
    
    SET [screen_cursor], J

    SET PC, Y
; end prc

:next_screen_cursor
DAT 0
:next_next_screen_cursor
DAT 0

; this function only uses Y, and J
:prend
SET Y, POP
:prend_with_y
SET [next_screen_cursor], [screen_cursor]
MOD [next_screen_cursor], 386

; round upwards to next multiple of 32
ADD [next_screen_cursor], 32
DVI [next_screen_cursor], 32
MLI [next_screen_cursor], 32

SET [next_next_screen_cursor], [next_screen_cursor]
ADD [next_next_screen_cursor], 32
MOD [next_screen_cursor], 386
MOD [next_next_screen_cursor], 386

SET J, [screen_cursor]

    :blank_current_line
    ; already blanked line
    IFC [J + 0x8000], 0b1111111100000000 ; if front and back colour are 0, aka all black
    SET PC, setup_blank_next_line

    ; black space
    SET [J + 0x8000], 0b0000000000001010

    ADD J, 1
    MOD J, 386
    IFN J, [next_screen_cursor]
    SET PC, blank_current_line
    
    
    
    :setup_blank_next_line
    SET J, [next_screen_cursor]



    :blank_next_line
    IFC [J + 0x8000], 0b1111111100000000
    SET PC, fin_blank_next_line

    ; black space
    SET [J + 0x8000], 0b0000000000001010

    ADD J, 1
    MOD J, 386
    IFN J, [next_next_screen_cursor]
    SET PC, blank_next_line

    :fin_blank_next_line



SET J, [next_screen_cursor]
SET [screen_cursor], [next_screen_cursor]
SET PC, Y

:getch
SET Y, POP
SET PUSH, 0
SET PC, Y
